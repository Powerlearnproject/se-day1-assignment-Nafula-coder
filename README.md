[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18441570&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the branch of computer science that deals with design,testing and maintenance of software applications.
1. Problem solving.Software engineering requires a variety of critical thinking and problem-solving skills which is vital to the technology industry.
2. Scalability in businesses. Software engineering is critical in supporting business growth and innovation.
3. Security and Privacy: Software Engineering practices include security considerations, helping to protect data and systems from cyber threats. This is particularly crucial in an era of increasing digital vulnerabilities.
4. Automation: Software engineering provide an environment for IT systems to depend on automation for tasks like data processing, backups, and security monitoring.
5. Customisation: Software Engineering enables the development of custom software applications that support tailored systems needs within the tech industry. 

Identify and describe at least three key milestones in the evolution of software engineering.
1. Early Days (1940s-1960s)
 Early programmers often had to write machine code, which is a low-level language that directly controls the computer's hardware.

2. The Software Crisis (1960s-1980s)
As the use of computers grew, the complexity of software systems increased.These problems became known as the "software crisis."

3. The Rise of Agile Development (1990s-present)
In the 1990s, there was a growing dissatisfaction with traditional software development methodologies. These methodologies were often seen as slow, bureaucratic, and inflexible. In response, a new approach called agile development emerged.

List and briefly explain the phases of the Software Development Life Cycle.
1. Planning: involves defining the software's purpose and scope, much like pinpointing our destination and plotting the best route. We uncover the tasks at hand during this phase and strategize for efficient execution.
2. Requirements Analysis: seeks to identify and record the precise requirements of the final users.
3. Design: is all about building the framework.
4. Coding: is when engineers and developers get down to business and start converting the software design into tangible code.
5. Testing: involves a thorough examination of the software for any bugs or glitches that might have slipped through during coding.
6. Deployment: involves rolling out the meticulously tested and fine-tuned software to its end-users.
7. Maintenance: is characterized by constant assistance and improvement, which guarantees the software's best possible functioning and longevity and ensures it meets customer expectations.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
The waterfall project management method is a linear, step-by-step approach that's ideal for projects with a clear scope and predictable timeline.
Agile project management is a flexible and iterative approach that enables teams to quickly adapt to changing project requirements and deliver high-quality results within shorter timeframes.
1. Planning: In waterfall, planning is a linear process done at the beginning of the project, with all requirements and objectives laid out in detail upfront. In contrast, agile planning is a continuous process throughout the project's life cycle, with adjustments made as new information or requirements emerge.
2. Speed: Waterfall projects tend to take longer because all requirements must be agreed upon before development can begin. Agile projects, on the other hand, are usually delivered more rapidly than waterfall projects due to the iterative development cycles used in agile.
3. Testing: Testing is essential to the agile and waterfall methodologies, but the approaches differ significantly. Agile emphasizes incremental testing to identify and resolve issues throughout the development process. In waterfall, testing is usually done at specific milestones, often towards the end of the project.
4. Time frames: The waterfall method is designed for long-term projects with predetermined timelines. The project is completed linearly, with each phase dependent on the previous one. Agile, however, uses short iterations to deliver value rapidly, allowing teams to adjust plans over time and achieve shorter time frames.
5. Documentation: Agile relies on minimal documentation, focusing on self-organizing teams and collaboration. Waterfall, in contrast, relies heavily on documenting each step in detail to ensure that all team members are on the same page.
   
Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
A Software developer is responsible for writing the code and developing the entire software product. 
Quality Assurance engineer develops tests that demonstrate how a product will react under expected and unexpected circumstances.
Project managers in software organize software projects and can assign tasks to software engineering teams according to the specifications of a task.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently. It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application.
A version control system (VCS) tracks every alteration to a file or set of files, enabling developers to journey back to earlier versions and collaborate seamlessly. 

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1. Growing Customer and Client Demands
Software engineers generally work on conceptual projects designed and developed to meet customer and client demands. Even within the most straightforward application or product development cycles, software engineers must understand underlying business concepts to ensure that the required features satisfy end users’ needs.
2. Software Testing Conflicts
Conflicts between software engineers and quality assurance (QA) testers can often arise during software development projects. Engineers may prioritize rapid feature delivery, while testers focus on ensuring stability and reliability, leading to potential disagreements over timelines and release readiness. Open communication, collaborative planning, and clear role definitions are essential to mitigating these issues and ensuring a smooth development process.
3. Software Accessibility and Usability
Overly complex software can frustrate or confuse users. Software engineers and developers should remember to build user-friendly assets, keep user interface (UI) designs consistent, and solicit user feedback frequently. Engineers must test software thoroughly and monitor software both during production and after it’s launched.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. Unit tests
Unit tests consist in testing individual methods and functions of the classes, components, or modules used by your software. Unit tests are generally quite cheap to automate and can run very quickly by a continuous integration server.
2. Integration tests
Integration tests verify that different modules or services used by your application work well together. For example, it can be testing the interaction with the database or making sure that microservices work together as expected. These types of tests are more expensive to run as they require multiple parts of the application to be up and running.
3. System tests
System tests are in two parts functional and end to end tests. Functional tests focus on the business requirements of an application while end to end tests replicates a user behavior with the software in a complete application environment.
4. Acceptance testing
Acceptance tests are formal tests that verify if a system satisfies business requirements. They require the entire application to be running while testing and focus on replicating user behaviors. 

#Part 2: Introduction to AI and Prompt Engineering

Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process where you guide generative artificial intelligence solutions to generate desired outputs. Prompt engineering has a series of benefits that include improved efficiency, accuracy, and personalization

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Draw a pussy cat looking in the sky.
Clarity: The better prompt specifically asks for a cat.
Specific Details: Describes the color of the cat and clearly provides an image of the cat.
Concise: The more details provide a clear picture making it easier for the artist to understand exactly what is needed.

